---
title: "Improving "
output: 
  html_notebook:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
---

Loading libraries and functions
```{r}
library(tidyverse)
source("function.R") # for F1 calculation
```
# loading training data
```{r}
data <- c("syn1","syn2","syn3","syn4","syn5","real1","real2_part1")
truthfiles <- paste0("data/", data, "/", data, "_truth.bed")
truthfiles[7] = "data/real2_part1/real2_truth_chr1to5.bed"
vcffiles <- paste0("output/snv-parse-", data, ".csv")


## data used for the model
full <- data.frame()

for (i in 1:6){
  truth <- read.table(truthfiles[i]) %>% # bed files
      mutate(prediction = TRUE) # add an additional column
  mypred <- preprocess.2(vcffiles[i])
  
  # write.table(mypred, paste0(data[i],"-processed.txt"), row.names = F, quote = F)
  # mypred <- read.csv(vcffiles[i])
  df <- left_join(mypred, truth, by = c("Chr"="V1", "START_POS_REF"="V2", "END_POS_REF"="V3")) %>%
      mutate(prediction = ifelse(is.na(prediction), FALSE, TRUE))
  full <- rbind(full, df)
}
```

## EDA
```{r}
true_all <- full[full$prediction,]
mutect2 <- true_all[true_all$Mutect2,]
freebayes <- true_all[true_all$Freebayes,]
vardict <- true_all[true_all$Vardict,]
varscan <- true_all[true_all$Varscan,]

x <- as.data.frame(colSums(true_all[,c(9:12,19:22)]))
x$name = rownames(x)
colnames(x)[1] = "count"
x <- x[order(x$count, decreasing = T),]
x
```

```{r}
true_all <- true_all %>%
  mutate(called = Mutect2 + Freebayes + Vardict + Varscan,
         filter = FILTER_Mutect2 + FILTER_Freebayes + FILTER_Vardict + FILTER_Varscan)

table(true_all$called)
table(true_all$filter)
hist(true_all$called)
hist(true_all$filter)
```
```{r}
eda <- function(file){
  check <- file
  x <- check[,19:22]
  hist(rowSums(x), main = "Number of detection")
  y <- check[,9:12]
  hist(rowSums(y), main = "Number of passes")
  z <- x&y
  hist(rowSums(z), main = "Number of passed detection")
  # ggplot(check, aes(x=m2_MQ)) + geom_bar()
  hist(check[,13], main = "mutect2 MQ", breaks = seq(0,70,by=0.5))
  print(range(check[,13], na.rm = T))
  hist(check[,14], main = "freebayes MQMR", breaks = seq(0,70,by=0.5))
  print(range(check[,14], na.rm = T))
  hist(check[,15], main = "varscan SSC", nclass = 50)
  print(range(check[,15], na.rm = T))
  hist(check[,16], main = "varscan SPV", nclass = 50)
  print(range(check[,16], na.rm = T))
  hist(check[,17], main = "vardict SSF", nclass = 50)
  print(range(check[,17], na.rm = T))
  hist(check[,18], main = "vardict MSI", nclass = 50)
  print(range(check[,18], na.rm = T))
}

eda(true_all)
```


# logistic regression
```{r}
###### fitting model #########
# library(caret)
start_time <- Sys.time()

vcf.fit = glm(prediction ~ Mutect2 + Freebayes + Vardict + Varscan + FILTER_Mutect2 + FILTER_Freebayes + FILTER_Vardict + FILTER_Varscan + m2_MQ + f_MQMR + vs_SSC + vs_SPV + vd_SSF + vd_MSI + FILTER + CALLED, data=full, family=binomial)

# vcf.fit = glm(prediction ~ FILTER_Mutect2 + FILTER_Freebayes + FILTER_Vardict + FILTER_Varscan + m2_MQ + f_MQMR + vs_SSC + vs_SPV + vd_SSF + vd_MSI, data=full, family=binomial)

# vcf.fit = glm(prediction ~ FILTER + avgMQ + vs_SPV + vd_SSF + vs_SSC + vd_MSI, data=full, family=binomial)

end_time <- Sys.time()
print(end_time - start_time)

summary(vcf.fit)
importances <- varImp(vcf.fit) 
importances <- importances %>%
  arrange(desc(Overall)) 
View(importances)
```

## tuning threshold
```{r}
# library(pROC)
par(pty = "s")
roc(full$prediction, vcf.fit$fitted.values, plot=TRUE,legacy.axes=TRUE)

## If we want to find out the optimal threshold we can store the 
## data used to make the ROC graph in a variable...
roc.info <- roc(full$prediction, vcf.fit$fitted.values, legacy.axes=TRUE)
str(roc.info)

## and then extract just the information that we want from that variable.
roc.df <- data.frame(
  tpp=roc.info$sensitivities*100, ## tpp = true positive percentage
  fpp=(1 - roc.info$specificities)*100, ## fpp = false positive precentage
  thresholds=roc.info$thresholds)

## now let's look at the thresholds between TPP 60% and 80%...
roc.df[roc.df$tpp > 60 & roc.df$tpp < 80,]

roc.df[roc.df$tpp >= 80 & roc.df$tpp < 85,]
x <-roc.df[roc.df$tpp >= 85 & roc.df$tpp < 90,]
```

## testing
```{r}
res <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

for (i in 7){
  truth <- read.table(truthfiles[i]) %>% # bed files
      mutate(prediction = TRUE) # add an additional column
  
  mypred <- preprocess.2(vcffiles[i])
  
  testing <- left_join(mypred, truth, by = c("Chr"="V1", "START_POS_REF"="V2", "END_POS_REF"="V3")) %>%
      mutate(prediction = ifelse(is.na(prediction), FALSE, TRUE))
  
  vcf.prob = predict(vcf.fit, testing, type="response")
  # testing$result[vcf.prob > .5] = TRUE
  # testing$result[vcf.prob <= .5] = FALSE
  
  called <- testing[vcf.prob > .964,1:3]
  f1stats <- calc.F1(called, truth[,1:3])
  res[i,] = c(data[i], f1stats)
}

res
```


```{r}
###### checking for best threshold #######
res <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

truth <- read.table(truthfiles[7]) %>% # bed files
    mutate(prediction = TRUE) # add an additional column
mypred <- preprocess.2(vcffiles[7])
testing <- left_join(mypred, truth, by = c("Chr"="V1", "START_POS_REF"="V2", "END_POS_REF"="V3")) %>%
    mutate(prediction = ifelse(is.na(prediction), FALSE, TRUE))
vcf.prob = predict(vcf.fit, testing, type="response")

count=1
for (i in seq(0.944,0.964, by=0.001)){
  called <- testing[vcf.prob > i,1:3]
  f1stats <- calc.F1(called, truth[,1:3])
  res[count,] = c(paste(i), f1stats)
  count <- count+1
}

res
```

## prediction
```{r}
testing <- preprocess.df("output/snv-parse-real2_part2.csv")
vcf.prob = predict(vcf.fit, testing, type="response")
testing = testing[,1:3]
testing$true[vcf.prob > .939] = 1
testing$true[vcf.prob <= .939] = 0
  
called <- testing[vcf.prob > .94,1:3]

write.table(testing,"team4_pred.bed", row.names = F, quote = F)
write.table(called,"team4_pred_trueonly.bed", row.names = F, quote = F)
```

## save model
```{r}
# Save the model to a file
saveRDS(vcf.fit, "logreg_model.rds")
```
