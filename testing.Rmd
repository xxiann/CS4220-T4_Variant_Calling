---
title: "Explore"
output: 
  html_notebook:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
---

Loading libraries and functions
```{r}
library(tidyverse)
source("function.R") # for F1 calculation
```

# assuming all calls are true calls
```{r}
vcf <- read.csv("output/snv-parse-syn1.csv")
head(vcf)
```

```{r}
truth = read.table("data/syn1/syn1_truth.bed") 
mypred = vcf[,1:3]

calc.F1(mypred, truth)
```

```{r}

## truth information
# data <- c("syn1","syn2","syn3","syn4","syn5","real1","real2_part1")
# truthfiles <- paste0("data/", data, "/", data, "_truth.bed")
# truthfiles[7] = "data/real2_part1/real2_truth_chr1to5.bed"
# vcffiles <- paste0("output/snv-parse-", data, ".csv")
# 
# for (i in 1:7){
#   mypred <- read.csv(vcffiles[i])
#   truth = read.table(truthfiles[i]) 
#   colnames(truth) = colnames(mypred)[1:3]
#   left_join(truth, mypred) %>%
#     write.csv(., paste0("truth/truth-", data[i], ".csv"), row.names = F)
# }

##
# setwd("./data/real1/")
# mutect2 <- Sys.glob("*mutect*vcf.gz")
# freebayes <- Sys.glob("*freebayes*vcf.gz")
# varscan <- Sys.glob("*varscan*vcf.gz")
# vardict <- Sys.glob("*vardict*vcf.gz")
# x<-list(mutect2,freebayes,varscan,vardict)
# 
# mutect2.tbi <- Sys.glob("*mutect*vcf.gz.tbi")
# freebayes.tbi <- Sys.glob("*freebayes*vcf.gz.tbi")
# varscan.tbi <- Sys.glob("*varscan*vcf.gz.tbi")
# vardict.tbi <- Sys.glob("*vardict*vcf.gz.tbi")
# tbi<-list(mutect2.tbi,freebayes.tbi,varscan.tbi,vardict.tbi)
# 
# library(VariantAnnotation)
# 
# ## checking info
# xx<-scanVcfHeader(x[[4]])
# c <- cbind(xx@header@listData[["INFO"]]@rownames,xx@header@listData[["INFO"]]@listData[["Description"]])
# View(c)
```


```{r}
data <- c("syn1","syn2","syn3","syn4","syn5","real1","real2_part1")
truthfiles <- paste0("data/", data, "/", data, "_truth.bed")
truthfiles[7] = "data/real2_part1/real2_truth_chr1to5.bed"
vcffiles <- paste0("output/snv-parse-", data, ".csv")

res <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

for (i in 1:7){
  mypred <- read.csv(vcffiles[i])[,1:3]
  truth = read.table(truthfiles[i]) 
  f1stats <- calc.F1(mypred, truth)
  res[i,] = c(data[i], f1stats)
}

res
```

# specific calls are true calls
- based on type of software used

## mutect2
```{r}
mutect2 <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

for (i in 1:7){
  mypred <- read.csv(vcffiles[i]) %>%
    filter(FILTER_Mutect2) %>%
    select(1:3)
  truth = read.table(truthfiles[i]) 
  f1stats <- calc.F1(mypred, truth)
  mutect2[i,] = c(data[i], f1stats)
}

mutect2
```
```{r}
mutect2[,1:4] %>% pivot_longer(.,cols = c("TP","FP","FN"), names_to = "accuracy", values_to = "count") %>%
  ggplot(., aes(x=dataset, y=count, fill=accuracy)) +
  geom_bar(stat = "identity", position = 'dodge')
```

## freebayes
```{r}
freebayes <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

for (i in 1:7){
  mypred <- read.csv(vcffiles[i]) %>%
    filter(FILTER_Freebayes) %>%
    select(1:3)
  truth = read.table(truthfiles[i]) 
  f1stats <- calc.F1(mypred, truth)
  freebayes[i,] = c(data[i], f1stats)
}

freebayes
```
```{r}
freebayes[,1:4] %>% pivot_longer(.,cols = c("TP","FP","FN"), names_to = "accuracy", values_to = "count") %>%
  ggplot(., aes(x=dataset, y=count, fill=accuracy)) +
  geom_bar(stat = "identity", position = 'dodge')
```

## Vardict
```{r}
vardict <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

for (i in 1:7){
  mypred <- read.csv(vcffiles[i]) %>%
    filter(FILTER_Vardict) %>%
    select(1:3)
  truth = read.table(truthfiles[i]) 
  f1stats <- calc.F1(mypred, truth)
  vardict[i,] = c(data[i], f1stats)
}

vardict
```
```{r}
vardict[,1:4] %>% pivot_longer(.,cols = c("TP","FP","FN"), names_to = "accuracy", values_to = "count") %>%
  ggplot(., aes(x=dataset, y=count, fill=accuracy)) +
  geom_bar(stat = "identity", position = 'dodge')
```

## Varscan
```{r}
varscan <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

for (i in 1:7){
  mypred <- read.csv(vcffiles[i]) %>%
    filter(FILTER_Varscan) %>%
    select(1:3)
  truth = read.table(truthfiles[i]) 
  f1stats <- calc.F1(mypred, truth)
  varscan[i,] = c(data[i], f1stats)
}

varscan
```

```{r}
varscan[,1:4] %>% pivot_longer(.,cols = c("TP","FP","FN"), names_to = "accuracy", values_to = "count") %>%
  ggplot(., aes(x=dataset, y=count, fill=accuracy)) +
  geom_bar(stat = "identity", position = 'dodge')
```



# checking consistencies in true calls
```{r}
for (i in 1:7){
  mypred <- read.csv(vcffiles[i]) # prediction
  x <- t(data.frame(strsplit(mypred$REF_MFVdVs, "/"), row.names =c("CALL_mutect2","CALL_freebayes","CALL_vardict","CALL_varscan")))
  rownames(x) <- c(1:nrow(x))
  x[!(is.na(x)|x=="NA")] = TRUE
  x[(is.na(x)|x=="NA")] = FALSE
  mypred <- cbind(mypred, x)
  truth <- read.table(truthfiles[i]) %>% # bed files
    mutate(prediction = TRUE) # add an additional column
  left_join(mypred, truth, by = c("Chr"="V1", "START_POS_REF"="V2", "END_POS_REF"="V3")) %>%
    mutate(prediction = ifelse(is.na(prediction), FALSE, TRUE)) %>%
    write.csv(., paste0("truth/truth-", data[i], ".csv"), row.names = F)
}

eda <- function(file){
  check <- read.csv(file) %>%
    filter(prediction)
  x <- check[,19:22]
  hist(rowSums(x), main = "Number of detection")
  y <- check[,9:12]
  hist(rowSums(y), main = "Number of passes")
  z <- x&y
  hist(rowSums(z), main = "Number of passed detection")
  # ggplot(check, aes(x=m2_MQ)) + geom_bar()
  hist(check[,13], main = "mutect2 MQ", breaks = seq(0,70,by=0.5))
  print(range(check[,13], na.rm = T))
  hist(check[,14], main = "freebayes MQMR", breaks = seq(0,70,by=0.5))
  print(range(check[,14], na.rm = T))
  hist(check[,15], main = "varscan SSC", nclass = 50)
  hist(check[,16], main = "varscan SPV", nclass = 50)
  hist(check[,17], main = "vardict SSF", nclass = 50)
  hist(check[,18], main = "vardict MSI", nclass = 50)
  print(range(check[,18], na.rm = T))
}
```

## max possible stats for truth calls 
```{r}
res <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

for (i in 1:7){
  mypred <- read.csv(paste0("truth/truth-", data[i], ".csv")) %>%
    filter(prediction) %>%
    select(1:3)
  truth = read.table(truthfiles[i]) 
  f1stats <- calc.F1(mypred, truth)
  res[i,] = c(data[i], f1stats)
}

res
```


## real1
```{r}
eda("truth/truth-real1.csv")

```
## syn1
```{r}
eda("truth/truth-syn1.csv")
```

## syn2
```{r}
eda("truth/truth-syn2.csv")
```
## syn3
```{r}
eda("truth/truth-syn3.csv")
```
## syn4
```{r}
eda("truth/truth-syn4.csv")
```
## syn5
```{r}
eda("truth/truth-syn5.csv")
```
```{r}
eda("truth/truth-real2_part1.csv")
```

# preprocessing
```{r}
preprocess <- function(file, count=2, mapq=40, p.value=0.05, p.v = 1, msi=1){
  df <- read.csv(file)
  m = nrow(df)
  df <- df %>%
    mutate(m2_MQ = ifelse(is.na(m2_MQ), ifelse(!is.na(f_MQMR), f_MQMR, 0), m2_MQ),
           f_MQMR = ifelse(is.na(f_MQMR), ifelse(!is.na(m2_MQ), m2_MQ, 0), f_MQMR)) %>%
    mutate(avgMQ = (m2_MQ+f_MQMR)/2,
           vs_SPV = ifelse((vs_SPV < p.value)&(!is.na(vs_SPV)), TRUE, FALSE),
           vd_SSF = ifelse((vd_SSF < p.value)&(!is.na(vd_SSF)), TRUE, FALSE)) %>%
    transmute(Chr = Chr,
              START_POS_REF = START_POS_REF,
              END_POS_REF = END_POS_REF,
              FILTER = FILTER_Mutect2 + FILTER_Freebayes + FILTER_Vardict + FILTER_Varscan,
              MQ = ifelse(avgMQ > mapq, TRUE, FALSE),
              P.V = vs_SPV + vd_SSF,
              MSI = ifelse((vd_MSI > msi)&(!is.na(vd_MSI)), TRUE, FALSE)) %>%
    filter((FILTER >= count ) | (MQ | (P.V >= p.v) | MSI))
  print(paste("from:", m, "to:", nrow(df)))
  return(df)
}
```

- passed + detected variant call == filter calls
```{r}
res <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

for (i in 1:7){
  mypred <- preprocess(vcffiles[i], p.v = 2, mapq = 50)[,1:3]
  truth = read.table(truthfiles[i]) 
  print(paste("Truth calls:", nrow(truth)))
  f1stats <- calc.F1(mypred, truth)
  res[i,] = c(data[i], f1stats)
}

res
```

# logistic regression
```{r}
## data used for the model
full <- data.frame()

for (i in 1:6){
  truth <- read.table(truthfiles[i]) %>% # bed files
      mutate(prediction = TRUE) # add an additional column
  mypred <- preprocess.2(vcffiles[i])
  
  # write.table(mypred, paste0(data[i],"-processed.txt"), row.names = F, quote = F)
  # mypred <- read.csv(vcffiles[i])
  df <- left_join(mypred, truth, by = c("Chr"="V1", "START_POS_REF"="V2", "END_POS_REF"="V3")) %>%
      mutate(prediction = ifelse(is.na(prediction), FALSE, TRUE))
  full <- rbind(full, df)
}

################# 
# mypred <- preprocess.2("output/snv-parse-real2_part2.csv")
# write.table(mypred, "real2_part2-processed.txt", row.names = F, quote = F)

# for (i in 1:6){
#   truth <- read.table(truthfiles[i]) %>% # bed files
#       mutate(prediction = TRUE) # add an additional column
#   mypred <- read.csv(vcffiles[i])
#   # mypred <- read.csv(vcffiles[i])
#   df <- left_join(mypred, truth, by = c("Chr"="V1", "START_POS_REF"="V2", "END_POS_REF"="V3")) %>%
#       mutate(prediction = ifelse(is.na(prediction), FALSE, TRUE))
#   full <- rbind(full, df)
# }
# full <- preprocess.mean(full)
```


```{r}
###### fitting model #########
# library(caret)
start_time <- Sys.time()

# vcf.fit = glm(prediction ~ Mutect2 + Freebayes + Vardict + Varscan + FILTER_Mutect2 + FILTER_Freebayes + FILTER_Vardict + FILTER_Varscan + m2_MQ + f_MQMR + vs_SSC + vs_SPV + vd_SSF + vd_MSI, data=full, family=binomial)

# vcf.fit = glm(prediction ~ FILTER_Mutect2 + FILTER_Freebayes + FILTER_Vardict + FILTER_Varscan + m2_MQ + f_MQMR + vs_SSC + vs_SPV + vd_SSF + vd_MSI, data=full, family=binomial)

vcf.fit = glm(prediction ~ FILTER + avgMQ + vs_SPV + vd_SSF + vs_SSC + vd_MSI, data=full, family=binomial)

end_time <- Sys.time()
print(end_time - start_time)

summary(vcf.fit)
importances <- varImp(vcf.fit) 
importances <- importances %>%
  arrange(desc(Overall)) 
View(importances)
```

## threshold
```{r}
#library(pROC)
par(pty = "s")
roc(full$prediction, vcf.fit$fitted.values, plot=TRUE,legacy.axes=TRUE)

## If we want to find out the optimal threshold we can store the 
## data used to make the ROC graph in a variable...
roc.info <- roc(full$prediction, vcf.fit$fitted.values, legacy.axes=TRUE)
str(roc.info)

## and then extract just the information that we want from that variable.
roc.df <- data.frame(
  tpp=roc.info$sensitivities*100, ## tpp = true positive percentage
  fpp=(1 - roc.info$specificities)*100, ## fpp = false positive precentage
  thresholds=roc.info$thresholds)

head(roc.df) ## head() will show us the values for the upper right-hand corner
             ## of the ROC graph, when the threshold is so low 
             ## (negative infinity) that every single sample is called "obese".
             ## Thus TPP = 100% and FPP = 100%

tail(roc.df) ## tail() will show us the values for the lower left-hand corner
             ## of the ROC graph, when the threshold is so high (infinity) 
             ## that every single sample is called "not obese". 
             ## Thus, TPP = 0% and FPP = 0%

## now let's look at the thresholds between TPP 60% and 80%...
roc.df[roc.df$tpp > 60 & roc.df$tpp < 80,]

## We can calculate the area under the curve...
roc(full$prediction, vcf.fit$fitted.values, plot=TRUE, legacy.axes=TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Postive Percentage", col="#377eb8", lwd=4, print.auc=TRUE)

## ...and the partial area under the curve.
roc(full$prediction, vcf.fit$fitted.values, plot=TRUE, legacy.axes=TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Postive Percentage", col="#377eb8", lwd=4, print.auc=TRUE, print.auc.x=45, partial.auc=c(100, 90), auc.polygon = TRUE, auc.polygon.col = "#377eb822")

```

```{r}
roc.df[roc.df$tpp >= 80 & roc.df$tpp < 85,]
x <-roc.df[roc.df$tpp >= 85 & roc.df$tpp < 90,]
```


## testing
```{r}
res <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

for (i in 7){
  truth <- read.table(truthfiles[i]) %>% # bed files
      mutate(prediction = TRUE) # add an additional column
  
  mypred <- preprocess.2(vcffiles[i])
  
  testing <- left_join(mypred, truth, by = c("Chr"="V1", "START_POS_REF"="V2", "END_POS_REF"="V3")) %>%
      mutate(prediction = ifelse(is.na(prediction), FALSE, TRUE))
  
  vcf.prob = predict(vcf.fit, testing, type="response")
  # testing$result[vcf.prob > .5] = TRUE
  # testing$result[vcf.prob <= .5] = FALSE
  
  called <- testing[vcf.prob > .945,1:3]
  f1stats <- calc.F1(called, truth[,1:3])
  res[i,] = c(data[i], f1stats)
}

# checking for best threshold
# truth <- read.table(truthfiles[7]) %>% # bed files
#     mutate(prediction = TRUE) # add an additional column
# mypred <- preprocess.2(vcffiles[7])
# testing <- left_join(mypred, truth, by = c("Chr"="V1", "START_POS_REF"="V2", "END_POS_REF"="V3")) %>%
#     mutate(prediction = ifelse(is.na(prediction), FALSE, TRUE))
# vcf.prob = predict(vcf.fit, testing, type="response")
# 
# count=1
# for (i in seq(0.957,0.963, by=0.001)){
#   called <- testing[vcf.prob > i,1:3]
#   f1stats <- calc.F1(called, truth[,1:3])
#   res[count,] = c(paste(i), f1stats)
#   count <- count+1
# }

res
```

## prediction
```{r}
testing <- preprocess.df("output/snv-parse-real2_part2.csv")
vcf.prob = predict(vcf.fit, testing, type="response")
testing = testing[,1:3]
testing$true[vcf.prob > .939] = 1
testing$true[vcf.prob <= .939] = 0
  
called <- testing[vcf.prob > .94,1:3]

write.table(testing,"team4_pred.bed", row.names = F, quote = F)
write.table(called,"team4_pred_trueonly.bed", row.names = F, quote = F)
```

## save model
```{r}
# Save the model to a file
saveRDS(vcf.fit, "logreg_model.rds")
```


# random forest
```{r}
# Loading package
library(caTools)
library(randomForest)
```

```{r}
# vcf.fit = glm(prediction ~ FILTER + avgMQ + vs_SPV + vd_SSF + vs_SSC + vd_MSI, data=full, family=binomial)
# 
# vcf.fit = glm(prediction ~ FILTER_Mutect2 + FILTER_Freebayes + FILTER_Vardict + FILTER_Varscan + m2_MQ + f_MQMR + vs_SPV + vd_SSF + vs_SSC + vd_MSI, data=full, family=binomial)

truth <- read.table(truthfiles[7]) %>% # bed files
      mutate(prediction = TRUE) # add an additional column
mypred <- preprocess.2(vcffiles[7])
testing <- left_join(mypred, truth, by = c("Chr"="V1", "START_POS_REF"="V2", "END_POS_REF"="V3")) %>%
      mutate(prediction = ifelse(is.na(prediction), FALSE, TRUE))


full$prediction <- factor(full$prediction)
# Fitting Random Forest to the train dataset
set.seed(120)  # Setting seed
model1 = randomForest(x = full[,c(9:11, 13:21)],
                      y = full$prediction,
                      ntree = 500)

model1
  
# Predicting the Test set results
y_pred = predict(model1, newdata = testing[,c(9:11, 13:21)])
  
# Confusion Matrix
confusion_mtx = table(testing$prediction, y_pred)
confusion_mtx
  
# Plotting model
plot(model1)
  
# Importance plot
importance(model1)
  
# Variable importance plot
varImpPlot(model1)
```

```{r}
x <- data.frame(predict = as.logical(y_pred))
prediction <- mypred[x$predict,] 

f1stats <- calc.F1(prediction, truth[,1:3])
f1stats
```

```{r}
model2 = randomForest(x = full[,c(15:18,20,21)],
                      y = full$prediction,
                      ntree = 500)

model2

# Predicting the Test set results
y_pred = predict(model2, newdata = testing[,c(15:20)])
  
# Confusion Matrix
confusion_mtx = table(testing$prediction, y_pred)
confusion_mtx
  
# Plotting model
plot(model2)
  
# Importance plot
importance(model2)
  
# Variable importance plot
varImpPlot(model2)
```


```{r}
x <- data.frame(predict = as.logical(y_pred))
prediction <- mypred[x$predict,] 

f1stats <- calc.F1(prediction, truth[,1:3])
f1stats
```














# naive comparison
```{r}
vc <- c("Mutect2", "Freebayes", "Vardict", "Varscan", "FILTER_Mutect2","FILTER_Freebayes","FILTER_Vardict","FILTER_Varscan")

res <- data.frame(dataset = character(),
                  TP = integer(), FP = integer(), FN = integer(), Precision = numeric(), Recall = numeric(), F1 = numeric())

truth <- read.table(truthfiles[7]) %>% # bed files
      mutate(prediction = TRUE) # add an additional column
mypred <- preprocess.2(vcffiles[7])
for (i in 1:8){
  called = mypred[mypred[,vc[i]],]
  f1stats <- calc.F1(called, truth[,1:3])
  res[i,] = c(vc[i], f1stats)
}

called = mypred[mypred[,vc[1]] & mypred[,vc[2]],]
f1stats <- calc.F1(called, truth[,1:3])
res[9,] = c("Mutect2 & Freebayes", f1stats)

called = mypred[mypred[,vc[5]] & mypred[,vc[6]],]
f1stats <- calc.F1(called, truth[,1:3])
res[10,] = c("FILTER Mutect2 & Freebayes", f1stats)

res
```

